//#############################################################################
//
// FILE:   vienna.h
//
//TITLE: solution hardware abstraction layer header file
//        This file consists of common variables and functions
//        for a particular hardware board, like functions to read current
//        and voltage signals on the board and functions to setup the
//        basic peripherals of the board
//
//#############################################################################
// $TI Release: TIDM_1000 v4.01.05.00 $
// $Release Date: Thu Dec 14 13:12:56 CST 2023 $
// $Copyright:
// Copyright (C) 2023 Texas Instruments Incorporated - http://www.ti.com/
//
// ALL RIGHTS RESERVED
// $
//#############################################################################


#ifndef VIENNA_H
#define VIENNA_H

#ifdef __cplusplus

extern "C" {
#endif

//************************ the includes *************************************

#include <stdint.h>

#ifndef __TMS320C28XX_CLA__
#include <math.h>
#else
#include <CLAmath.h>
#endif

//
// this is the file generated by the powerSUITE page for this system
//
#include "vienna_settings.h"
#include "vienna_hal.h"

//
// Library header files
// DCL Library is used for the controller implementation
// GV -> parallel form of DCL_PI for voltage loop (gv),
//
#ifndef __TMS320C28XX_CLA__
#include "DCLF32.h"

#define VIENNA_GV DCL_PI
//
// gv on C28x, run DCL_PI routine written in assembly
//
#define VIENNA_GV_RUN DCL_runPI_C4

#else
#include "DCLCLA.h"

#define VIENNA_GV DCL_PI_CLA

//
// gv on CLA, run DCL_PI routine written as inline function
// because it is called in the background task
//
#define VIENNA_GV_RUN DCL_runPI_L2

#endif

#include "dlog_4ch.h"

#include "power_meas_sine_analyzer.h"
#pragma FUNC_ALWAYS_INLINE(POWER_MEAS_SINE_ANALYZER_run)
#ifndef __TMS320C28XX_CLA__
#include "sfra_f32.h"
#include "sfra_gui_scicomms_driverlib.h"
#define VIENNA_SFRA_INJECT SFRA_F32_inject
#define VIENNA_SFRA_COLLECT SFRA_F32_collect
#else
#define VIENNA_SFRA_INJECT(m)    m
#define VIENNA_SFRA_COLLECT(m, n)
#endif


#define EMAVG_MACRO(in, out)  out = ((in - out) * (float32_t)0.000528) + out;

//
// System Settings
//
#define VIENNA_GRID_MAX_FREQ_HZ ((float32_t)110)
#define VIENNA_GRID_MIN_FREQ_HZ ((float32_t)40)

#define VIENNA_SD32_PU_SCALE_FACTOR ((float32_t)(1.0f / ((float32_t)VIENNA_SDFM_OSR * VIENNA_SDFM_OSR * VIENNA_SDFM_OSR)))

#define VIENNA_ALL_PHASE_ENABLED 1
#define VIENNA_CHECK_PHASE 2

//
// typedefs
//

enum VIENNA_boardState_enum {
    PowerStageOFF = 0,
    PowerStageON = 1,
    TripCondition = 2,
};

enum VIENNA_BuildLevel_enum {
    BuildLevel_1_OpenLoop = 0,
    BuildLevel_2_CurrentLoop = 1,
    BuildLevel_3_VoltageAndCurrentLoop = 2,
    BuildLevel_4_BalanceVoltageAndCurrentLoop = 3,
    BuildLevel_1_OpenLoop_CLA = 4,
    BuildLevel_2_CurrentLoop_CLA = 5,
    BuildLevel_3_VoltageAndCurrentLoop_CLA = 6,
    BuildLevel_4_BalanceVoltageAndCurrentLoop_CLA = 7,

};

enum VIENNA_boardStatus_enum {
    boardStatus_Idle = 0,
    boardStatus_NoFault = 1,
    boardStatus_OverCurrentTrip_IL1 = 2,
    boardStatus_OverCurrentTrip_IL2 = 3,
    boardStatus_OverCurrentTrip_IL3 = 4,
    boardStatus_OverCurrentTrip = 5,
    boardStatus_OverVoltageTrip = 6,
    boardStatus_BusImbalanceTrip = 7,
    boardStatus_EmulatorStopTrip = 8,
};

//
//********************** globals **********************************************
//

//
// DCL Library, voltage compensator
// DC Bus set point
//
extern volatile float32_t VIENNA_vBusRef_pu;
extern volatile float32_t VIENNA_vBusRefSlewed_pu;

extern VIENNA_GV VIENNA_gv;

extern volatile float32_t VIENNA_gv_out,  VIENNA_voltage_error_pu;
extern volatile uint16_t VIENNA_nonLinearVoltageLoopFlag;

//
// Current compensator
// Peak value of the Ii, Io current set point
//
extern volatile float32_t VIENNA_iLRef_pu, VIENNA_iL1Ref_pu, VIENNA_iL2Ref_pu,
                          VIENNA_iL3Ref_pu;

extern volatile float32_t VIENNA_gi_out1, VIENNA_gi_out2, VIENNA_gi_out3;
extern volatile float32_t VIENNA_gi_gainKp;

//
// Balance controller
//
extern volatile float32_t VIENNA_gs_gainKp;
extern volatile float32_t VIENNA_gs_out;

extern volatile float32_t VIENNA_vBusDiff_pu, VIENNA_vBusZero_pu;

//
// Sine analyzer block for RMS Volt, Curr and Power measurements
//
extern POWER_MEAS_SINE_ANALYZER VIENNA_sine_mains1, VIENNA_sine_mains2,
                                VIENNA_sine_mains3;

//
// Control Variables
// Measurement Variables
// Inductor Current Measurement
//
extern volatile float32_t VIENNA_iL1MeasADC_pu, VIENNA_iL2MeasADC_pu,
                          VIENNA_iL3MeasADC_pu;
extern volatile float32_t VIENNA_iL1MeasSD_pu, VIENNA_iL2MeasSD_pu,
                          VIENNA_iL3MeasSD_pu;
extern volatile float32_t VIENNA_iL1Meas_pu, VIENNA_iL2Meas_pu, VIENNA_iL3Meas_pu;

//
// Inductor Current Measurement Offset
//
extern volatile float32_t VIENNA_iL1MeasOffset_pu, VIENNA_iL2MeasOffset_pu,
                          VIENNA_iL3MeasOffset_pu;

//
// Output Voltage Bus measurement
//
extern volatile float32_t VIENNA_vBusMNMeas_pu, VIENNA_vBusPMMeas_pu, VIENNA_vBusMeas_pu,
                          VIENNA_vBusHalfMeas_pu;
extern volatile float32_t VIENNA_vBusMNMeasAvg_pu, VIENNA_vBusPMMeasAvg_pu,
                          VIENNA_vBusMeasAvg_pu;

//
// variables used for calibration of output voltage measurements
//
extern volatile float32_t VIENNA_m_VBusMNMeas_pu, VIENNA_b_VBusMNMeas_pu;
extern volatile float32_t VIENNA_m_VBusPMMeas_pu, VIENNA_b_VBusPMMeas_pu;

//
// Input Grid Voltage Measurement
//
extern volatile float32_t VIENNA_v1Meas_pu, VIENNA_v2Meas_pu, VIENNA_v3Meas_pu;
extern volatile float32_t VIENNA_v1MeasOffset_pu, VIENNA_v2MeasOffset_pu,
                          VIENNA_v3MeasOffset_pu;

extern volatile float32_t VIENNA_vRmsMeasAvg_pu;

//
// Variables used to calibrate measurement offsets
//
extern float32_t VIENNA_k1, VIENNA_k2, VIENNA_offset165;

//
// Display Values
//
extern volatile float32_t  VIENNA_guiVbusMN_Volts, VIENNA_guiVbusPM_Volts, VIENNA_guiVbus_Volts,
    VIENNA_guiV1_Volts, VIENNA_guiV2_Volts, VIENNA_guiV3_Volts,
    VIENNA_guiIL1_Amps, VIENNA_guiIL2_Amps, VIENNA_guiIL3_Amps,
    VIENNA_guiIL1sd_Amps, VIENNA_guiIL2sd_Amps, VIENNA_guiIL3sd_Amps;

extern volatile float32_t VIENNA_guiACFreq_Hz;
extern volatile float32_t VIENNA_guiPrms1_W, VIENNA_guiPrms2_W, VIENNA_guiPrms3_W,
                VIENNA_guiPrmsTotal_W;
extern volatile float32_t VIENNA_guiIrms1_Amps, VIENNA_guiIrms2_Amps, VIENNA_guiIrms3_Amps;
extern volatile float32_t VIENNA_guiVrms1_Volts, VIENNA_guiVrms2_Volts, VIENNA_guiVrms3_Volts;
extern volatile float32_t VIENNA_guiPF1, VIENNA_guiPF2, VIENNA_guiPF3;
extern volatile float32_t VIENNA_guiVA1_VA, VIENNA_guiVA2_VA, VIENNA_guiVA3_VA;

extern float32_t VIENNA_guiVbusTripLimit_Volts;

extern uint16_t VIENNA_guiPowerStageStart;
extern uint16_t VIENNA_guiPowerStageStop;

//
// PFC Filtered DC bus measurement
//
extern volatile float32_t VIENNA_vBusAvg_pu;

extern volatile float32_t VIENNA_iL1_CalibrationGain;
extern volatile float32_t VIENNA_iL2_CalibrationGain;
extern volatile float32_t VIENNA_iL3_CalibrationGain;

//
// variables for third harmmonic injection
//
extern volatile float32_t VIENNA_vMin_pu, VIENNA_vMax_pu;
extern volatile float32_t VIENNA_thirdHarmonicInjection;

//
// individual duty cycles for each phase
//
extern volatile float32_t VIENNA_duty1PU, VIENNA_duty2PU, VIENNA_duty3PU;
extern volatile float32_t VIENNA_dutyPU_DC;

//
// Flags for clearing trips and closing the loops
//
extern int16_t VIENNA_closeGiLoop, VIENNA_closeGvLoop, VIENNA_closeGsLoop,
               VIENNA_clearTrip, VIENNA_firstTimeGvLoop;

extern volatile int16_t VIENNA_thirdHarmonicInjectionEnable;

extern volatile float32_t VIENNA_iL1Ref_prev_pu, VIENNA_iL2Ref_prev_pu,
                          VIENNA_iL3Ref_prev_pu;
extern volatile float32_t VIENNA_inductor_voltage_drop_feedforward1,
                          VIENNA_inductor_voltage_drop_feedforward2,
                          VIENNA_inductor_voltage_drop_feedforward3;

extern volatile uint16_t VIENNA_busVoltageSlew;

//
//-----------------------------------------------------------------------------
// Enum for build level of software and board status
//
extern enum VIENNA_BuildLevel_enum VIENNA_buildInfo;

extern enum VIENNA_boardState_enum VIENNA_boardState;

extern enum VIENNA_boardStatus_enum VIENNA_boardStatus;

#ifndef __TMS320C28XX_CLA__

//
// datalogger
//
extern DLOG_4CH VIENNA_dLog1;
extern float32_t VIENNA_dBuff1[100], VIENNA_dBuff2[100], VIENNA_dBuff3[100],
                 VIENNA_dBuff4[100];
extern float32_t VIENNA_dVal1, VIENNA_dVal2, VIENNA_dVal3, VIENNA_dVal4;

//
//--- SFRA Related Variables ----
//
extern float32_t VIENNA_plantMagVect[VIENNA_SFRA_FREQ_LENGTH];
extern float32_t VIENNA_plantPhaseVect[VIENNA_SFRA_FREQ_LENGTH];
extern float32_t VIENNA_olMagVect[VIENNA_SFRA_FREQ_LENGTH];
extern float32_t VIENNA_olPhaseVect[VIENNA_SFRA_FREQ_LENGTH];
extern float32_t VIENNA_freqVect[VIENNA_SFRA_FREQ_LENGTH];

extern SFRA_F32 VIENNA_sfra1;
#endif

//
//*********************** the function prototypes *************************
//

#ifndef __TMS320C28XX_CLA__
   extern void VIENNA_setupSFRA();
   extern void VIENNA_runSFRABackGroundTasks();
   extern void VIENNA_updateBoardStatus(void);
   extern void VIENNA_globalVariablesInit(void);
   extern void VIENNA_calibrateOffset(void);
#else

#endif


#pragma FUNC_ALWAYS_INLINE(VIENNA_readCurrVolADCSignals)

//
// readCurrVolADCSignals()
//
static inline void VIENNA_readCurrVolADCSignals(void)
{

    VIENNA_iL1Meas_pu = (((float32_t)(VIENNA_IL1_FB_1 + VIENNA_IL1_FB_2 +
            VIENNA_IL1_FB_3 + VIENNA_IL1_FB_4)) *
            VIENNA_ADC_PU_SCALE_FACTOR * 0.25f - VIENNA_iL1MeasOffset_pu ) * 2.0f;
    VIENNA_iL2Meas_pu = (((float32_t)(VIENNA_IL2_FB_1 + VIENNA_IL2_FB_2 +
            VIENNA_IL2_FB_3 + VIENNA_IL2_FB_4)) *
            VIENNA_ADC_PU_SCALE_FACTOR * 0.25f - VIENNA_iL2MeasOffset_pu ) * 2.0f;
    VIENNA_iL3Meas_pu = (((float32_t)(VIENNA_IL3_FB_1 + VIENNA_IL3_FB_2 +
            VIENNA_IL3_FB_3 + VIENNA_IL3_FB_4)) *
            VIENNA_ADC_PU_SCALE_FACTOR * 0.25f - VIENNA_iL3MeasOffset_pu ) * 2.0f;

    VIENNA_v1Meas_pu = (((float32_t)(VIENNA_V1_FB_1 + VIENNA_V1_FB_2 +
            VIENNA_V1_FB_3 + VIENNA_V1_FB_4)) *
            VIENNA_ADC_PU_SCALE_FACTOR * 0.25f - VIENNA_v1MeasOffset_pu ) * 2.0f;
    VIENNA_v2Meas_pu = (((float32_t)(VIENNA_V2_FB_1 + VIENNA_V2_FB_2 +
            VIENNA_V2_FB_3 + VIENNA_V2_FB_4)) *
            VIENNA_ADC_PU_SCALE_FACTOR * 0.25f - VIENNA_v2MeasOffset_pu ) * 2.0f;
    VIENNA_v3Meas_pu = (((float32_t)(VIENNA_V3_FB_1 + VIENNA_V3_FB_2 +
            VIENNA_V3_FB_3 + VIENNA_V3_FB_4)) *
            VIENNA_ADC_PU_SCALE_FACTOR * 0.25f - VIENNA_v3MeasOffset_pu ) * 2.0f;

    VIENNA_vBusPMMeas_pu = (((float32_t)(VIENNA_VBUSPM_FB_1 + VIENNA_VBUSPM_FB_2
                         + VIENNA_VBUSPM_FB_3 + VIENNA_VBUSPM_FB_4)) *
            VIENNA_ADC_PU_SCALE_FACTOR * 0.25f ) *
                    VIENNA_VDCBUS_MAX_SENSE_VOLTS / VIENNA_VAC_MAX_SENSE_VOLTS;
    VIENNA_vBusMNMeas_pu = (((float32_t)(VIENNA_VBUSMN_FB_1 + VIENNA_VBUSMN_FB_2
                         + VIENNA_VBUSMN_FB_3 + VIENNA_VBUSMN_FB_4)) *
            VIENNA_ADC_PU_SCALE_FACTOR * 0.25f ) *
                    VIENNA_VDCBUS_MAX_SENSE_VOLTS / VIENNA_VAC_MAX_SENSE_VOLTS;

    //
    // y = mx+ b equation used to reduce offset and gain error
    //
    VIENNA_vBusPMMeas_pu = VIENNA_m_VBusPMMeas_pu * VIENNA_vBusPMMeas_pu +
                        VIENNA_b_VBusPMMeas_pu;
    VIENNA_vBusMNMeas_pu = VIENNA_m_VBusMNMeas_pu * VIENNA_vBusMNMeas_pu +
                        VIENNA_b_VBusMNMeas_pu;

    VIENNA_vBusMeas_pu = VIENNA_vBusPMMeas_pu + VIENNA_vBusMNMeas_pu;
    VIENNA_vBusHalfMeas_pu = (VIENNA_vBusMeas_pu) * 0.5f;

    //
    // clamp the vBusHalfMeas before dividing to avoid NaN
    //
    VIENNA_vBusHalfMeas_pu = (VIENNA_vBusHalfMeas_pu < 0.2f)?0.2f:VIENNA_vBusHalfMeas_pu;
}

//
// readCurrVolSDFMSignals()
//
static inline void VIENNA_readCurrVolSDFMSignals(float32_t sdfm_scale_factor)
{

    VIENNA_iL1MeasSD_pu = (float32_t)( ( (int32_t)
                       SDFM_getFilterData(VIENNA_IL1_SDFM_BASE,
                       VIENNA_IL1_SDFM_FILTER)) * VIENNA_SD32_PU_SCALE_FACTOR);

    VIENNA_iL2MeasSD_pu = (float32_t)( ( (int32_t)
                       SDFM_getFilterData(VIENNA_IL2_SDFM_BASE,
                       VIENNA_IL2_SDFM_FILTER)) * VIENNA_SD32_PU_SCALE_FACTOR);

    VIENNA_iL3MeasSD_pu = (float32_t)( ( (int32_t)
                       SDFM_getFilterData(VIENNA_IL3_SDFM_BASE,
                       VIENNA_IL3_SDFM_FILTER)) * VIENNA_SD32_PU_SCALE_FACTOR);

    VIENNA_iL1Meas_pu = VIENNA_iL1MeasSD_pu *
                     (VIENNA_I_MAX_SENSE_SD_AMPS / VIENNA_I_MAX_SENSE_AMPS);
    VIENNA_iL2Meas_pu = VIENNA_iL2MeasSD_pu * (VIENNA_I_MAX_SENSE_SD_AMPS /
                     VIENNA_I_MAX_SENSE_AMPS);
    VIENNA_iL3Meas_pu = VIENNA_iL3MeasSD_pu * (VIENNA_I_MAX_SENSE_SD_AMPS /
                     VIENNA_I_MAX_SENSE_AMPS);
}

//
// clearPWMTrip()
//
static inline void VIENNA_clearPWMTrip()
{
    if(VIENNA_clearTrip == 1)
    {
        //
        // clear all the configured trip sources for the PWM module
        //
        VIENNA_HAL_clearPWMTripFlags(VIENNA_HIGH_FREQ_PWM1_BASE);
        VIENNA_HAL_clearPWMTripFlags(VIENNA_HIGH_FREQ_PWM2_BASE);
        VIENNA_HAL_clearPWMTripFlags(VIENNA_HIGH_FREQ_PWM3_BASE);
        VIENNA_HAL_clearCMPSSLatchFlags(VIENNA_BOARD_PROT_IL1_CUR_CMPSS_BASE);
        VIENNA_HAL_clearCMPSSLatchFlags(VIENNA_BOARD_PROT_IL2_CUR_CMPSS_BASE);
        VIENNA_HAL_clearCMPSSLatchFlags(VIENNA_BOARD_PROT_IL3_CUR_CMPSS_BASE);

        VIENNA_clearTrip = 0;
        VIENNA_closeGiLoop = 1;

        #if VIENNA_INCR_BUILD == 3 || VIENNA_INCR_BUILD == 4
            VIENNA_closeGvLoop = 1;
            VIENNA_closeGsLoop = 1;
        #else
            VIENNA_closeGvLoop = 0;
        #endif

    }

}

#pragma FUNC_ALWAYS_INLINE(VIENNA_pfcControlCode)

//
// control Code
//
static inline void VIENNA_pfcControlCode(void)
{
    VIENNA_HAL_setProfilingGPIO();

    VIENNA_readCurrVolADCSignals();

    #if VIENNA_SDFM_SENSING == 1
        VIENNA_readCurrVolSDFMSignals(VIENNA_SD32_PU_SCALE_FACTOR);
    #endif

    #if(VIENNA_ALL_PHASE_ENABLED == 1)
        VIENNA_clearPWMTrip();
    #else
        if(VIENNA_clearTrip == 1)
        {
            #if CHECK_PHASE == 1
                clearPWMTripFlags(VIENNA_HIGH_FREQ_PWM1_BASE);
            #elif CHECK_PHASE == 2
                clearPWMTripFlags(VIENNA_HIGH_FREQ_PWM2_BASE);
            #elif CHECK_PHASE == 3
                clearPWMTripFlags(VIENNA_HIGH_FREQ_PWM3_BASE);
            #else
                #warning define CHECK_PHASE in this build
            #endif
            VIENNA_clearTrip = 0;
        }
    #endif

    //
    // BUILD 1
    // Open Loop Check
    //
    #if(VIENNA_INCR_BUILD == 1)
//      VIENNA_duty1PU = VIENNA_dutyPU_DC;
        VIENNA_duty1PU = VIENNA_SFRA_INJECT(VIENNA_dutyPU_DC);
        VIENNA_duty2PU = VIENNA_dutyPU_DC;
        VIENNA_duty3PU = VIENNA_dutyPU_DC;

    //
    // (VIENNA_INCR_BUILD == 1)
    //
    #endif

    //
    // Closed Current Loop
    //
    #if(VIENNA_INCR_BUILD == 2 || VIENNA_INCR_BUILD == 3 || VIENNA_INCR_BUILD == 4)

        VIENNA_iL1Ref_pu = VIENNA_iLRef_pu * (VIENNA_v1Meas_pu / VIENNA_vRmsMeasAvg_pu);
        VIENNA_iL2Ref_pu = VIENNA_iLRef_pu * (VIENNA_v2Meas_pu / VIENNA_vRmsMeasAvg_pu);
        VIENNA_iL3Ref_pu = VIENNA_iLRef_pu * (VIENNA_v3Meas_pu / VIENNA_vRmsMeasAvg_pu);

        #if VIENNA_INDUCTOR_VOLTAGE_DROP_FEEDFORWARD == 1

        //
        // inductor voltage drop feed forward (L*di/dt)
        //
        VIENNA_inductor_voltage_drop_feedforward1 =
                    (VIENNA_iL1Ref_pu - VIENNA_iL1Ref_prev_pu) *
                    (VIENNA_PFC_INDUCTOR_VALUE * VIENNA_ISR_CONTROL_FREQUENCY_HZ
                    * VIENNA_I_MAX_SENSE_AMPS / VIENNA_V_MAX_SENSE_VOLTS);
        VIENNA_inductor_voltage_drop_feedforward2 =
                    (VIENNA_iL2Ref_pu - VIENNA_iL2Ref_prev_pu) *
                    (VIENNA_PFC_INDUCTOR_VALUE * VIENNA_ISR_CONTROL_FREQUENCY_HZ
                    * VIENNA_I_MAX_SENSE_AMPS / VIENNA_V_MAX_SENSE_VOLTS);
        VIENNA_inductor_voltage_drop_feedforward3 =
                    (VIENNA_iL3Ref_pu - VIENNA_iL3Ref_prev_pu) *
                    (VIENNA_PFC_INDUCTOR_VALUE * VIENNA_ISR_CONTROL_FREQUENCY_HZ
                    * VIENNA_I_MAX_SENSE_AMPS / VIENNA_V_MAX_SENSE_VOLTS);
        #else
            VIENNA_inductor_voltage_drop_feedforward1 = 0;
            VIENNA_inductor_voltage_drop_feedforward2 = 0;
            VIENNA_inductor_voltage_drop_feedforward3 = 0;
        #endif

        #ifdef __TMS320C28XX_CLA__
            #if(CLA_DEBUG == 1)
                __mdebugstop();
            #endif
        #endif

        if(VIENNA_closeGiLoop == 1)
        {

            #if VIENNA_SFRA_TYPE == VIENNA_SFRA_CURRENT
                VIENNA_gi_out1 = (VIENNA_iL1Meas_pu -
                        VIENNA_SFRA_INJECT(VIENNA_iL1Ref_pu)) * VIENNA_gi_gainKp;
            #else
                VIENNA_gi_out1 = (VIENNA_iL1Meas_pu - VIENNA_iL1Ref_pu) *
                VIENNA_gi_gainKp;
            #endif
                VIENNA_gi_out2 = (VIENNA_iL2Meas_pu - VIENNA_iL2Ref_pu) *
                VIENNA_gi_gainKp;
                VIENNA_gi_out3 = (VIENNA_iL3Meas_pu - VIENNA_iL3Ref_pu) *
                VIENNA_gi_gainKp;

            #if VIENNA_THIRD_HARMONIC_INJECTION == 0
                VIENNA_thirdHarmonicInjection = 0;
            #else
                VIENNA_vMin_pu = (VIENNA_v1Meas_pu < VIENNA_v2Meas_pu)?
                               VIENNA_v1Meas_pu:VIENNA_v2Meas_pu;
                VIENNA_vMin_pu = (VIENNA_vMin_pu < VIENNA_v3Meas_pu)?
                               VIENNA_vMin_pu:VIENNA_v3Meas_pu;
                VIENNA_vMax_pu = (VIENNA_v1Meas_pu > VIENNA_v2Meas_pu)?
                               VIENNA_v1Meas_pu:VIENNA_v2Meas_pu;
                VIENNA_vMax_pu = (VIENNA_vMax_pu > VIENNA_v3Meas_pu)?
                               VIENNA_vMax_pu:VIENNA_v3Meas_pu;

                VIENNA_thirdHarmonicInjection = (VIENNA_vMin_pu + VIENNA_vMax_pu)
                                                * 0.5f;
            #endif


                VIENNA_duty1PU = ( (VIENNA_gi_out1
                            + VIENNA_inductor_voltage_drop_feedforward1
                            + VIENNA_v1Meas_pu
                            - VIENNA_thirdHarmonicInjection
                            ) / VIENNA_vBusHalfMeas_pu ) - VIENNA_gs_out;

                VIENNA_duty2PU = ( (VIENNA_gi_out2
                            + VIENNA_inductor_voltage_drop_feedforward2
                            + VIENNA_v2Meas_pu
                            - VIENNA_thirdHarmonicInjection
                            ) / VIENNA_vBusHalfMeas_pu ) - VIENNA_gs_out;


                VIENNA_duty3PU = ( (VIENNA_gi_out3
                            + VIENNA_inductor_voltage_drop_feedforward3
                            + VIENNA_v3Meas_pu
                            - VIENNA_thirdHarmonicInjection
                             ) / VIENNA_vBusHalfMeas_pu ) - VIENNA_gs_out;
        }
        else
        {
            VIENNA_duty1PU = 1.0f;
            VIENNA_duty2PU = 1.0f;
            VIENNA_duty3PU = 1.0f;
        }

    #endif

    //
    // PWM Driver for three phase Vienna Rectifier PFC
    //
    VIENNA_duty1PU = (VIENNA_duty1PU > 1.0f)?1.0f:VIENNA_duty1PU;
    VIENNA_duty1PU = (VIENNA_duty1PU < -1.0f)?-1.0f:VIENNA_duty1PU;
    VIENNA_duty2PU = (VIENNA_duty2PU > 1.0f)?1.0f:VIENNA_duty2PU;
    VIENNA_duty2PU = (VIENNA_duty2PU < -1.0f)?-1.0f:VIENNA_duty2PU;
    VIENNA_duty3PU = (VIENNA_duty3PU > 1.0f)?1.0f:VIENNA_duty3PU;
    VIENNA_duty3PU = (VIENNA_duty3PU < -1.0f)?-1.0f:VIENNA_duty3PU;

    VIENNA_HAL_updatePFCviennaPWM(VIENNA_HIGH_FREQ_PWM1_BASE,
                                  VIENNA_HIGH_FREQ_PWM2_BASE,
                                  VIENNA_HIGH_FREQ_PWM3_BASE,
                                  VIENNA_duty1PU,
                                  VIENNA_duty2PU,
                                  VIENNA_duty3PU);

    VIENNA_iL1Ref_prev_pu = VIENNA_iL1Ref_pu;
    VIENNA_iL2Ref_prev_pu = VIENNA_iL2Ref_pu;
    VIENNA_iL3Ref_prev_pu = VIENNA_iL3Ref_pu;

    #ifdef __TMS320C28XX_CLA__
       #if(CLA_DEBUG == 1)
           __mdebugstop();
       #endif
    #endif

    //
    // BUILD 3
    //
    #if(VIENNA_INCR_BUILD == 3 || VIENNA_INCR_BUILD == 4)

        if(VIENNA_closeGvLoop == 1)
        {
            if(VIENNA_firstTimeGvLoop == 1)
            {
                VIENNA_vBusRefSlewed_pu = VIENNA_vBusMeas_pu;
                VIENNA_firstTimeGvLoop = 0;
            }

            VIENNA_voltage_error_pu = fabs(VIENNA_vBusRefSlewed_pu - VIENNA_vBusMeas_pu);

            if(VIENNA_nonLinearVoltageLoopFlag == 0)
            {
                VIENNA_gv.Kp = VIENNA_GV_PI_KP;
                VIENNA_gv.Ki = VIENNA_GV_PI_KI;
            }
            else
            {
               if(VIENNA_voltage_error_pu > 0.005f)
               {
                   if(VIENNA_gv.Kp < (VIENNA_NON_LINEAR_V_LOOP_KP_MULTIPLIER
                           * VIENNA_GV_PI_KP))
                   {
                       VIENNA_gv.Kp = VIENNA_gv.Kp + 0.05f;
                   }
               }
               else if(VIENNA_voltage_error_pu < 0.001f)
               {
                   if(VIENNA_gv.Kp > VIENNA_GV_PI_KP)
                   {
                       VIENNA_gv.Kp = VIENNA_gv.Kp - 0.05f;
                   }
               }
            }

            #if VIENNA_SFRA_TYPE == VIENNA_SFRA_VOLTAGE
                VIENNA_gv_out = VIENNA_GV_RUN(&VIENNA_gv,
                                VIENNA_SFRA_INJECT(VIENNA_vBusRefSlewed_pu),
                                VIENNA_vBusMeas_pu);
            #else
                VIENNA_gv_out = VIENNA_GV_RUN(&VIENNA_gv, VIENNA_vBusRefSlewed_pu,
                                            VIENNA_vBusMeas_pu);
            #endif

                //
                // Output of the voltage loop is thought to be the Power
                //
                VIENNA_iLRef_pu = VIENNA_gv_out *
                        (VIENNA_vBusMeasAvg_pu / (3 * VIENNA_vRmsMeasAvg_pu));

        }
    #endif



    #if(VIENNA_INCR_BUILD == 4)
        if(VIENNA_closeGsLoop == 1)
        {
            VIENNA_vBusDiff_pu = VIENNA_vBusPMMeas_pu - VIENNA_vBusMNMeas_pu;

            #if VIENNA_SFRA_TYPE == VIENNA_SFRA_BALANCECNTL
                VIENNA_gs_out = (VIENNA_vBusDiff_pu - VIENNA_SFRA_INJECT(VIENNA_vBusZero_pu))
                                * VIENNA_gs_gainKp;
//              VIENNA_gs_out = (VIENNA_vBusDiff_pu)*VIENNA_gs_gainKp;
            #else
                VIENNA_gs_out = (VIENNA_vBusDiff_pu) * VIENNA_gs_gainKp;
            #endif
        }
        else
        {
            VIENNA_gs_out = 0;
        }
    #else
        VIENNA_gs_out = 0;
    #endif

    //
    //Running FRA on Voltage
    //
    #if(VIENNA_SFRA_TYPE == VIENNA_SFRA_VOLTAGE )
        VIENNA_SFRA_COLLECT((float32_t *)&VIENNA_gv_out,
                            (float32_t *)&VIENNA_vBusMeas_pu);

    //
    //running FRA on Current
    //
    #elif(VIENNA_SFRA_TYPE == VIENNA_SFRA_CURRENT)
        VIENNA_SFRA_COLLECT((float32_t *)&VIENNA_gi_out1,
                            (float32_t *)&VIENNA_iL1Meas_pu);
    #elif(VIENNA_SFRA_TYPE == VIENNA_SFRA_BALANCECNTL)
        VIENNA_SFRA_COLLECT((float32_t *)&VIENNA_gs_out,
                            (float32_t *)&VIENNA_vBusDiff_pu);
    #endif

   VIENNA_HAL_clearPWMInterruptFlag(VIENNA_C28x_ISR1_INTERRUPT_TRIG_PWM_BASE);

   VIENNA_HAL_resetProfilingGPIO();
}

#pragma FUNC_ALWAYS_INLINE(VIENNA_instrumentationCode)

//
// voltage loop plus instrumentation code
//
static inline void VIENNA_instrumentationCode()
{
    //
    // Let the ISR1 interrupt this routine
    //
#if VIENNA_INSTRUMENTATION_ISR_RUNNING_ON == C28x_CORE
    EINT;
#endif
    VIENNA_HAL_setProfilingGPIO2();

    if(VIENNA_closeGvLoop == 1)
    {
        if(fabsf(VIENNA_vBusRef_pu - VIENNA_vBusRefSlewed_pu) > 0.1f)
        {
            if(VIENNA_vBusRef_pu > VIENNA_vBusRefSlewed_pu)
            {
                VIENNA_vBusRefSlewed_pu = VIENNA_vBusRefSlewed_pu + 0.0001f;
            }
            else
            {
                VIENNA_vBusRefSlewed_pu = VIENNA_vBusRefSlewed_pu - 0.0001f;
            }
        }
        else if(fabsf(VIENNA_vBusRef_pu - VIENNA_vBusRefSlewed_pu) > 0.01f)
        {
            if(VIENNA_vBusRef_pu > VIENNA_vBusRefSlewed_pu)
            {
                VIENNA_vBusRefSlewed_pu = VIENNA_vBusRefSlewed_pu + 0.00005f;
            }
            else
            {
                VIENNA_vBusRefSlewed_pu = VIENNA_vBusRefSlewed_pu - 0.00005f;
            }
        }
        else if(fabsf(VIENNA_vBusRef_pu - VIENNA_vBusRefSlewed_pu) > 0.005f)
        {
            if(VIENNA_vBusRef_pu > VIENNA_vBusRefSlewed_pu)
            {
                VIENNA_vBusRefSlewed_pu = VIENNA_vBusRefSlewed_pu + 0.00001f;
            }
            else
            {
                VIENNA_vBusRefSlewed_pu = VIENNA_vBusRefSlewed_pu - 0.00001f;
            }
        }
        else
        {
            VIENNA_vBusRefSlewed_pu = VIENNA_vBusRef_pu;
        }
    }


    if(VIENNA_PWM_EMU_TRIP_STATUS(VIENNA_HIGH_FREQ_PWM1_BASE))
    {
        VIENNA_boardStatus = boardStatus_Idle;
    }
    else if(VIENNA_guiVbus_Volts > VIENNA_guiVbusTripLimit_Volts || VIENNA_guiVbusPM_Volts > 415.0f
            || VIENNA_guiVbusMN_Volts > 415.0f)
    {
        VIENNA_HAL_forceOSTPWMTrip(VIENNA_HIGH_FREQ_PWM1_BASE);
        VIENNA_HAL_forceOSTPWMTrip(VIENNA_HIGH_FREQ_PWM2_BASE);
        VIENNA_HAL_forceOSTPWMTrip(VIENNA_HIGH_FREQ_PWM3_BASE);
        VIENNA_boardStatus =   boardStatus_OverVoltageTrip;
    }
    else if(fabsf(VIENNA_guiVbusPM_Volts - VIENNA_guiVbusMN_Volts) > 50)
    {
        VIENNA_HAL_forceOSTPWMTrip(VIENNA_HIGH_FREQ_PWM1_BASE);
        VIENNA_HAL_forceOSTPWMTrip(VIENNA_HIGH_FREQ_PWM2_BASE);
        VIENNA_HAL_forceOSTPWMTrip(VIENNA_HIGH_FREQ_PWM3_BASE);
        VIENNA_boardStatus = boardStatus_BusImbalanceTrip;
    }
    else if(VIENNA_CURR_TRIP_LATCH_STATUS(VIENNA_BOARD_PROT_IL1_CUR))
    {
        VIENNA_boardStatus = boardStatus_OverCurrentTrip_IL1;
    }
    else if(VIENNA_CURR_TRIP_LATCH_STATUS(VIENNA_BOARD_PROT_IL2_CUR))
    {
        VIENNA_boardStatus = boardStatus_OverCurrentTrip_IL2;
    }
    else if(VIENNA_CURR_TRIP_LATCH_STATUS(VIENNA_BOARD_PROT_IL3_CUR))
    {
        VIENNA_boardStatus = boardStatus_OverCurrentTrip_IL3;
    }
    else if(VIENNA_PWM_OC_TRIP_STATUS(VIENNA_HIGH_FREQ_PWM1_BASE)!= 0)
    {
        VIENNA_boardStatus = boardStatus_OverCurrentTrip;
    }
    else
    {
        VIENNA_boardStatus = boardStatus_NoFault;
    }

    EMAVG_MACRO(VIENNA_vBusPMMeas_pu, VIENNA_vBusPMMeasAvg_pu);
    EMAVG_MACRO(VIENNA_vBusMNMeas_pu, VIENNA_vBusMNMeasAvg_pu);

    VIENNA_vBusMeasAvg_pu = VIENNA_vBusPMMeasAvg_pu + VIENNA_vBusMNMeasAvg_pu;

    VIENNA_guiVbusPM_Volts = VIENNA_vBusPMMeasAvg_pu * VIENNA_V_MAX_SENSE_VOLTS;
    VIENNA_guiVbusMN_Volts = VIENNA_vBusMNMeasAvg_pu * VIENNA_V_MAX_SENSE_VOLTS;
    VIENNA_guiVbus_Volts = VIENNA_guiVbusPM_Volts + VIENNA_guiVbusMN_Volts;

    VIENNA_guiV1_Volts = VIENNA_v1Meas_pu * VIENNA_V_MAX_SENSE_VOLTS;
    VIENNA_guiV2_Volts = VIENNA_v2Meas_pu * VIENNA_V_MAX_SENSE_VOLTS;
    VIENNA_guiV3_Volts = VIENNA_v3Meas_pu * VIENNA_V_MAX_SENSE_VOLTS;

    VIENNA_guiIL1_Amps = VIENNA_iL1Meas_pu * VIENNA_I_MAX_SENSE_AMPS;
    VIENNA_guiIL2_Amps = VIENNA_iL2Meas_pu * VIENNA_I_MAX_SENSE_AMPS;
    VIENNA_guiIL3_Amps = VIENNA_iL3Meas_pu * VIENNA_I_MAX_SENSE_AMPS;

//  VIENNA_guiIL1sd = VIENNA_iL1MeasSD_pu * VIENNA_I_MAX_SENSE_SD_AMPS;
//  VIENNA_guiIL2sd = VIENNA_iL2MeasSD_pu * VIENNA_I_MAX_SENSE_SD_AMPS;
//  VIENNA_guiIL3sd = VIENNA_iL3MeasSD_pu * VIENNA_I_MAX_SENSE_SD_AMPS;

    //
    // Sine Analyzer
    // Calculate RMS input voltage and input frequency
    //
    VIENNA_sine_mains1.i = VIENNA_iL1Meas_pu;
    VIENNA_sine_mains1.v = VIENNA_v1Meas_pu;
    POWER_MEAS_SINE_ANALYZER_run(&VIENNA_sine_mains1);

    VIENNA_sine_mains2.i = VIENNA_iL2Meas_pu;
    VIENNA_sine_mains2.v = VIENNA_v2Meas_pu;
    POWER_MEAS_SINE_ANALYZER_run(&VIENNA_sine_mains2);

    VIENNA_sine_mains3.i = VIENNA_iL3Meas_pu;
    VIENNA_sine_mains3.v = VIENNA_v3Meas_pu;
    POWER_MEAS_SINE_ANALYZER_run(&VIENNA_sine_mains3);

    EMAVG_MACRO(VIENNA_sine_mains1.vRms, VIENNA_vRmsMeasAvg_pu);

    VIENNA_guiIrms1_Amps = VIENNA_sine_mains1.iRms * VIENNA_I_MAX_SENSE_AMPS;
    VIENNA_guiVrms1_Volts = VIENNA_sine_mains1.vRms * VIENNA_V_MAX_SENSE_VOLTS;
    VIENNA_guiPrms1_W = VIENNA_sine_mains1.pRms * VIENNA_V_MAX_SENSE_VOLTS *
                      VIENNA_I_MAX_SENSE_AMPS;
    VIENNA_guiPF1 = VIENNA_sine_mains1.powerFactor;
    VIENNA_guiVA1_VA = VIENNA_sine_mains1.vaRms * VIENNA_V_MAX_SENSE_VOLTS *
                    VIENNA_I_MAX_SENSE_AMPS;

    VIENNA_guiIrms2_Amps = VIENNA_sine_mains2.iRms * VIENNA_I_MAX_SENSE_AMPS;
    VIENNA_guiVrms2_Volts = VIENNA_sine_mains2.vRms * VIENNA_V_MAX_SENSE_VOLTS;
    VIENNA_guiPrms2_W = VIENNA_sine_mains2.pRms * VIENNA_V_MAX_SENSE_VOLTS *
                      VIENNA_I_MAX_SENSE_AMPS;
    VIENNA_guiPF2 = VIENNA_sine_mains2.powerFactor;
    VIENNA_guiVA2_VA = VIENNA_sine_mains2.vaRms * VIENNA_V_MAX_SENSE_VOLTS *
                    VIENNA_I_MAX_SENSE_AMPS;

    VIENNA_guiIrms3_Amps = VIENNA_sine_mains3.iRms * VIENNA_I_MAX_SENSE_AMPS;
    VIENNA_guiVrms3_Volts = VIENNA_sine_mains3.vRms * VIENNA_V_MAX_SENSE_VOLTS;
    VIENNA_guiPrms3_W = VIENNA_sine_mains3.pRms * VIENNA_V_MAX_SENSE_VOLTS *
                      VIENNA_I_MAX_SENSE_AMPS;
    VIENNA_guiPF3 = VIENNA_sine_mains3.powerFactor;
    VIENNA_guiVA3_VA = VIENNA_sine_mains3.vaRms * VIENNA_V_MAX_SENSE_VOLTS *
                    VIENNA_I_MAX_SENSE_AMPS;

    VIENNA_guiACFreq_Hz = VIENNA_sine_mains1.acFreqAvg;

#ifndef __TMS320C28XX_CLA__

    //
    // DLOG
    //********** Connect inputs of the Datalogger module *******************
    //

    //
    // check voltage and inductor current meas.
    //
    VIENNA_dVal1 = VIENNA_guiV1_Volts;
    VIENNA_dVal2 = VIENNA_iL1Meas_pu;
    VIENNA_dVal3 = VIENNA_iL2Meas_pu;
    VIENNA_dVal4 = VIENNA_iL3Meas_pu;

    DLOG_4CH_run(&VIENNA_dLog1);
#endif

    VIENNA_HAL_resetProfilingGPIO2();

}


#ifdef __cplusplus
}
#endif                                  /* extern "C" */


#endif
